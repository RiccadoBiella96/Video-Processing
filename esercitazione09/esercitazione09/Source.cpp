/*#include <iostream>
#include <opencv2/opencv.hpp>
using namespace std;
using namespace cv;
int main(int argc, char **argv)
{
	int x;
	int framerate;
	cout << "Vuoi riprodurre il video secondo il frame rate originale oppure cambiarlo ? 0/1";
	cin >> x;
	VideoCapture cap("videoauto.mp4");
	if (x == 1) {
		cout << "Inserire il frame rate :";
		cin >> framerate;
		cap.set(CV_CAP_PROP_FPS, framerate); //funzione utile per cmbiare il frame rate
	}
	else {
		cout << "hai scelto di fare rimanere il frame rate originale del video !!!!";
		framerate = cap.get(CV_CAP_PROP_FPS);
		cout << "Frame rate di default =";
		cout << framerate;
		//cap.set(CV_CAP_PROP_FPS, framerate);
	}
	


	if (!cap.isOpened())
		return -1;
	namedWindow("video", 1);
	Mat frame;
	Mat frame_gray;
	int count = 0;
	for (;;)
	{

		cap >> frame;		
		if (frame.rows == 0 && frame.cols == 0) {
			cout << "last frame!" << endl;
			break;
		}
		cvtColor(frame, frame_gray, CV_RGB2GRAY);
		imshow("video1", frame);
		imshow("video2", frame_gray);
		if (count <= 10) {
			string name = "immagine_" + to_string(count) + ".png";
			imwrite(name, frame);
		}
		count++;

		if (waitKey(1000/framerate) >= 0) break;
	} 
	return 0;
}*/


#include <iostream>
#include <opencv2/opencv.hpp>

using namespace std;
using namespace cv;

int main(int argc, char **argv) {
	VideoCapture cap("C:\\Users\\Luca\\Desktop\\SUPSI\\terza\\multimedia\\esercitazione9\\videoauto.mp4");
	if (!cap.isOpened())
		return -1;

	namedWindow("video", 1);
	Mat frame;
	Mat frame_gray;
	Rect trackWindow1;
	Rect trackWindow;
	trackWindow = Rect(880, 220, 30, 30);
	trackWindow1 = Rect(20, 240, 30, 30);

	Rect s_trackWindow1;
	Rect s_trackWindow;
	s_trackWindow = Rect(880, 220, 30, 30);
	s_trackWindow1 = Rect(20, 240, 30, 30);

	RotatedRect prec_track;
	RotatedRect prec_track1;
	Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
	Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
	pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method

	for (;;) {
		cap >> frame;
		if (frame.rows == 0 && frame.cols == 0) {
			cout << "last frame!" << endl;
			break;
		}

		// 1. convert in grayscale
		cvtColor(frame, frame_gray, CV_RGB2GRAY);
		// 2. use the background subtraction MOG2 algorithm to obatin the fore ground image
		pMOG2->apply(frame, fgMaskMOG2);
		// 3. filter the noise by using one or more morphological filters
		Mat erode_frame;
		Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
		cv::erode(fgMaskMOG2, erode_frame, kernel);
		//in erode_frame avremmo l'immagine dopo l'applicazione del filtro
	// 4. apply a threshold to better define the fore ground
		Mat t_frame;
		threshold(erode_frame, t_frame, 100, 255, THRESH_BINARY);
		//nel frame t_frame abbbiamo l'immagine una volta che si è applicato il filtro di threshold
	// 5. if needed, use one ore more morphological filters to improve the fore ground definition

	// 6. find a way to track the cars using the camshift algorithm (hint: implement an object to handle the tracker)
		//da destra  a sinistra 
		//ROSSO
		Rect temp = trackWindow;
		RotatedRect trackBox = CamShift(t_frame, temp, TermCriteria(TermCriteria::EPS | TermCriteria::COUNT, 10, 1));
		float area = trackBox.size.area();
		if (area <= 0) {
			rectangle(frame, trackWindow, Scalar(0, 0, 255), 3, LINE_AA, 0);
		}
		if (trackBox.center.x < prec_track.center.x) {
			Rect ret = trackBox.boundingRect();
			trackWindow = ret;
			rectangle(frame, trackWindow, Scalar(0, 0, 255), 3, LINE_AA, 0);
			//std::cout << "Sto andando da sinistra a destra!!!";
			if (trackBox.center.x < 50) {
				trackWindow = Rect(880, 220, 10, 10);
			}
		}
		trackWindow = s_trackWindow;
			//da sinistra a destra 
			//VERDE
		RotatedRect trackBox1 = CamShift(t_frame, trackWindow1, TermCriteria(TermCriteria::EPS | TermCriteria::COUNT, 10, 1));
		float area1 = trackBox1.size.area();
		if (area1 <= 0) {
			rectangle(frame, Rect(20, 240, 30, 30) , Scalar(0, 255, 0), 3, LINE_AA, 0);
		}
		if (trackBox1.center.x > prec_track1.center.x) {
			Rect ret1 = trackBox1.boundingRect();
			rectangle(frame, ret1, Scalar(0, 255, 0), 3, LINE_AA, 0);
			//std::cout << "Sto andando da destra a sinistra!!";
			if (trackBox1.center.x > 800) {
				//devo riportare all'inizio il trackbox
				trackWindow1= Rect(20, 240, 30, 30);
			}
		}		
		prec_track1 = trackBox1;
			
		// 7. extract the requested information (number of vehicles, number of vehicles for each direction, timestamp, color)

		// 8. save ONE frame for the vehicle with the requested information written on

		imshow("video", frame);
		if (waitKey(120) >= 0) break;
	}

	return 0;
}



